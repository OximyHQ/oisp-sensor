//! Policy Engine - YAML-based DSL for defining security rules
//!
//! The policy engine evaluates events against user-defined rules and executes
//! actions like allow, block, redact, or alert.
//!
//! # Architecture
//!
//! ```text
//! ┌─────────────┐    ┌──────────────┐    ┌─────────────┐
//! │   Event     │───>│   Policy     │───>│   Action    │
//! │  (OispEvent)│    │  Evaluator   │    │  Executor   │
//! └─────────────┘    └──────────────┘    └─────────────┘
//!                           │
//!                    ┌──────┴──────┐
//!                    │   Policy    │
//!                    │   Manager   │
//!                    └─────────────┘
//!                           │
//!                    ┌──────┴──────┐
//!                    │  policies.  │
//!                    │    yaml     │
//!                    └─────────────┘
//! ```
//!
//! # Example Policy
//!
//! ```yaml
//! policies:
//!   - id: block-unknown-apps
//!     name: Block requests from unknown apps
//!     enabled: true
//!     priority: 100
//!     conditions:
//!       all:
//!         - field: event_type
//!           op: equals
//!           value: ai.request
//!         - field: app.tier
//!           op: equals
//!           value: unknown
//!     action:
//!       type: block
//!       reason: "Blocked: unknown application"
//! ```

pub mod actions;
pub mod audit;
pub mod condition;
pub mod evaluator;
pub mod manager;
pub mod parser;
pub mod plugin;

// Re-export commonly used types
pub use actions::{ActionExecutor, ActionResult, PolicyAction, PolicyActionType};
pub use audit::{AuditEvent, AuditLogger, AuditSeverity};
pub use condition::{Condition, ConditionOp, FieldPath};
pub use evaluator::{EvaluationResult, PolicyEvaluator};
pub use manager::{PolicyManager, PolicyManagerConfig};
pub use parser::{parse_policies, Policy, PolicyFile};
pub use plugin::PolicyPlugin;

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Default policy file location
pub fn default_policy_path() -> PathBuf {
    dirs::config_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("oisp")
        .join("policies.yaml")
}

/// Policy engine configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyConfig {
    /// Path to the policy file
    #[serde(default = "default_policy_path")]
    pub policy_file: PathBuf,

    /// Enable hot-reload of policies when file changes
    #[serde(default = "default_true")]
    pub hot_reload: bool,

    /// Enable audit logging
    #[serde(default = "default_true")]
    pub audit_enabled: bool,

    /// Audit log file path (None = stdout)
    #[serde(default)]
    pub audit_file: Option<PathBuf>,

    /// Default action when no policy matches
    #[serde(default)]
    pub default_action: DefaultAction,

    /// Webhook URL for alerts (optional)
    #[serde(default)]
    pub alert_webhook_url: Option<String>,
}

fn default_true() -> bool {
    true
}

impl Default for PolicyConfig {
    fn default() -> Self {
        Self {
            policy_file: default_policy_path(),
            hot_reload: true,
            audit_enabled: true,
            audit_file: None,
            default_action: DefaultAction::Allow,
            alert_webhook_url: None,
        }
    }
}

/// Default action when no policy matches
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum DefaultAction {
    /// Allow the event through (default)
    #[default]
    Allow,
    /// Block the event
    Block,
    /// Log but allow
    Log,
}

/// Result of policy processing
#[derive(Debug, Clone)]
pub struct PolicyResult {
    /// The policy that matched (if any)
    pub matched_policy: Option<String>,
    /// The action taken
    pub action: PolicyActionType,
    /// Reason for the action
    pub reason: Option<String>,
    /// Whether the event was modified
    pub modified: bool,
    /// Alerts generated
    pub alerts: Vec<PolicyAlert>,
}

/// Alert generated by a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyAlert {
    /// Alert ID
    pub id: String,
    /// Policy that generated the alert
    pub policy_id: String,
    /// Alert severity
    pub severity: AlertSeverity,
    /// Alert message
    pub message: String,
    /// Event ID that triggered the alert
    pub event_id: String,
    /// Timestamp
    pub timestamp: chrono::DateTime<chrono::Utc>,
    /// Additional context
    #[serde(default)]
    pub context: std::collections::HashMap<String, serde_json::Value>,
}

/// Alert severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
#[derive(Default)]
pub enum AlertSeverity {
    Info,
    #[default]
    Warning,
    Critical,
}
